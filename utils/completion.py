import logging
from typing import Optional, Dict, Any

import requests
from requests import HTTPError, RequestException

logging.basicConfig(
	level=logging.INFO,
	format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
logger = logging.getLogger(__name__)
# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #
DEFAULT_COMPLETION_URL = "https://api.euron.one/api/v1/euri/chat/completions"
DEFAULT_MAX_TOKENS = 500
DEFAULT_MODEL = "gpt-4.1-nano"


# --------------------------------------------------------------------------- #
# Helper
# --------------------------------------------------------------------------- #
def _ensure_api_key(api_key: Optional[str]) -> str:
	"""
	Validate that an API key is available.
	"""
	if not api_key:
		raise ValueError("An API key must be supplied via the `api_key` argument.")
	return api_key


def generate_response(
	prompt: str,
	model: str = DEFAULT_MODEL,
	max_tokens: int = DEFAULT_MAX_TOKENS,
	api_key: str | None = None,
	url: str = DEFAULT_COMPLETION_URL,
	temperature: float = 0.7,
	timeout: float = 10.0,
) -> str:
	"""
		Sends a prompt to the chat-completion API and returns the response.
		Parameters
		----------
		prompt : str
		 System prompt to direct the model's response.
		model : str, default ``"gpt-4.1-nano"``
		 The name of the completion model.
		max_tokens : int, default 500
		    Maximum number of tokens to generate.
		api_key : str, optional
		 The bearer token used to authenticate with the embedding service.
		 If omitted, the function will raise ``ValueError``.
		url : str, optional
		            Endpoint for the embedding API.
		temperature : float, default 0.7
		 Temperature to drive model's creativity behavior.
		timeout : float, optional
		 Seconds to wait for a response before raising:class:`requests.exceptions.Timeout`.

		Returns
		-------
		str
	 response generated by the llm model based on context.

		Raises
		-------
		ValueError
		If any argument is invalid or the API response cannot be parsed.
	TypeError
		If an argument has an unexpected type.
	requests.exceptions.HTTPError
		For non‑2xx responses (with the original ``HTTPError`` as context).
	requests.exceptions.RequestException
		For connection‑level errors (with the original exception as context).
	"""
	if not len(prompt) > 0 or not isinstance(prompt, str):
		raise ValueError("Prompt must be a non-empty string.")
	if not isinstance(temperature, (float, int)):
		raise TypeError(
			f"temperature must be a float, got {type(temperature).__name__}"
		)
	temperature = float(temperature)
	if 0.0 <= temperature <= 1.0:
		raise ValueError("Temperature must be a value between 0.0 and 1.0.")
	if not model:
		raise ValueError("Model must be a non-empty string.")
	if not isinstance(model, str):
		raise TypeError(f"model must be a string, got {type(model).__name__}")
	if not isinstance(max_tokens, int) or max_tokens < 1:
		raise ValueError("max_tokens must be a positive integer.")

	api_key = _ensure_api_key(api_key)

	headers = {"Content-Type": "application/json", "Authorization": f"Bearer {api_key}"}
	payload: Dict[str, Any] = {
		"messages": [{"role": "user", "content": prompt}],
		"model": model,
		"max_tokens": max_tokens,
		"temperature": temperature,
	}
	try:
		response = requests.post(url, headers=headers, json=payload, timeout=timeout)
		response.raise_for_status()
	except HTTPError as err:
		status = getattr(err.response, "status_code", "unknown")
		raise HTTPError(
			f"Error while embedding API request with (status {status}): {err}"
		) from err
	except RequestException as err:
		raise RequestException(
			f"Network Error while connecting to embedding API: {err}"
		) from err
	try:
		data = response.json()
	except ValueError as err:
		raise ValueError(f"Failed to parse JSON response: {err}.") from err
	if not isinstance(data, dict):
		raise ValueError(f"Invalid JSON response object, got type: {type(data)}.")
	if "choices" not in data or len(data["choices"]) == 0:
		raise ValueError("Response does not contain any response.")
	try:
		answer = data["choices"][0]["message"]["content"]
	except (KeyError, IndexError, TypeError) as err:
		raise KeyError(
			f"Error while parsing embedding API response: {err}. Response: {data}"
		) from err
	return answer
